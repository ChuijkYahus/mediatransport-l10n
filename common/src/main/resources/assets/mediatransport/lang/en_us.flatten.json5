{
  mediatransport: {
    book: {
      category: {
        interop: {
          figura: {
            "": "Figura",
            desc: "It appears that these constructs called $(thing)avatars/$ are quite powerful, if a bit annoying to work with."
          }
        }
      },
      patterns: {
        figura: {
          "": "Transport Patterns",
          intro: "",
          send_fsb: "Sends the iota on the top of the stack into the ether to be received by my current avatar. Can fail for $(l:hexcasting:interop/figura/mishaps)various reasons$(/l).",
          send_other: "Sends the iota on the top of the stack to be received by the player second from the top of the stack. It seems to have a separate receiver from the other one.",
          recv_fsb: "Retrieves the next iota from the $(thing)inbound queue/$, or $(l:hexcasting:interop/figura/mishaps)mishaps$(/l) if the queue is empty.",
          check_queue: "Checks the number of received iotas that are ready to be read. [todo]",
        },
      },
      interop: {
        figura: {
          about: {
            "": "Transports",
            "1": "I appear to have discovered the notes of a collective of people who have also discovered the techniques of _Hexcasting. I've copied down what I could understand of the notes, but the last part is incomprehensible to me, and I've attached it as is. Perhaps I need to understand more about the artistry of these '$(thing)avatars/$' I see mentioned throughout the notes?",
            "2": "The first section of the notes was dedicated to something called a $(hex)chatcaster/$. They seemed to describe a complex system that acts in response to what someone $(italic)speaks/$, rather than the patterns that they cast. I can certainly see the utility, especially for reducing the load on my mind (and my pockets) by not having to carry a $(thing)Spellbook/$ around with everything I want in it.",
            "3": "However, it seems that the $(thing)avatars/$ these _Hexcasters used was able to $(italic)mimic/$ the interaction with Nature that one's speaking would normally invoke. The combination of these two systems allows proficient artists to compute complex inputs and run $(hex)Hexes/$ at a rate I had never anticipated.$(br2)In contrast, the second half of the notes detail something much more interesting...",
            "4": "It appears that Nature created new patterns for communicating specifically with $(thing)avatars/$ after the artists continued to use their avatars to communicate more and more rapidly. As seems to be standard, Nature has twisted the appearance of the now-familiar iotas in exchange for this increased efficiency and throughput; they appear as boxes and seemingly random symbols by my eyes. The $(thing)avatars/$ and their artists seem to not have this problem, and have figured out how to decode the mess.",
            "5": "Here's the rest of their notes for future reference. To be honest, I don't recognize much of what they mention.",
            "A": "So we got a few new patterns (dubiously spells as well?) recently, and they facilitate direct communication between avatars and hexes! no more getting kicked for spam :D$(br2)Some of the more data-oriented of us have decoded the format. The entire thing is byte-aligned and uses $(#8bf)buffers/$ for data transfer. (that means we have to remember to close them!)",
            "B": "Based on what we've seen, each iota starts with a single-byte $(#8bf)type/$ followed by zero or more bytes of $(#8bf)data/$. All multibyte forms are big endian. (that's the default for the Buffer read methods)$(br2)",
            "C1": "Unfortunately, due to annoying restrictions with this unwieldy notebook, it's difficult to express the format in more detail here. Perhaps it would be easier in a $(l:https://penguinencounter.github.io/mediatransport/v/latest/main/en_us/mediatransport_virtual/protocol)more flexible medium$(/l)?",
            "C2": "The format in its entirety is described here: $(l:hexcasting:mediatransport_virtual/protocol)Iota Transport Protocol$(/l)"
          },
          mishaps: {
            "": "Transport Mishaps",
            "1": "Various things can go wrong when interacting with the esoteric language of avatar transports.",
            // first italic part is the same as first part of the mishap text
            init_fail: "$(italic)Figura server isn't initialized .../$$(br2)Occurs if the server is misconfigured or if this universe is an \"integrated server\". Causes grey sparks and a general feeling of disappointment.",
            bad_type: "$(italic)can't send ... because that type of iota can't be sent/$$(br2)That type of iota can't be submitted to Nature for transmission. Causes black sparks.$(br2)$(italic)Need support for an iota type? Ask on $(l:https://github.com/penguinencounter/mediatransport/issues)GitHub$(/l)!/$",
            corrupted: "$(italic)can't send ... because it's corrupted or ill-formed/$$(br2)Something has gone horribly wrong. Causes black sparks, and probably should be reported on the relevant GitHub issue tracker.",
            matrix_too_large: "$(italic)can't send ... because it's too big$(br)can't send ... because it has too many rows$(br)can't send ... because it has too many columns/$$(br2)The matrix you're trying to send has too many entries to be sent, or more than 255 rows or columns. Causes black sparks.",
            iota_too_large: "$(italic)can't send: calculated size at least .../$$(br2)The iota you're sending is larger than the maximum allowed size. Causes black sparks.$(br2)$(italic)Note: Server administrators can change the limit in the config./$",
            iota_too_large_inter: "$(italic)can't send to other players: calculated size at least .../$$(br2)The iota you're sending to another player's avatar is larger than the maximum allowed size. Causes black sparks.$(br2)$(italic)Note: Server administrators can change the limit in the config./$",
            radio_silence: "Tried to accept an iota, but there's nothing to accept (i.e. the queue is empty.) Causes white sparks and the screams of $(k)the tormented minds/$ to echo within my ears.",
            "2": "it looks like most of these errors only occur when $(italic)sending/$ (well, \"submitting\") data from within nature's domain. nature seems to be much more lenient in accepting bad data... in that it doesn't crash anything and instead outputs its favorite flavor of not-error: garbage!$(br)unfortunately this makes it hard to determine why data isn't making it across the boundary. we've compiled a list of reasons to look out for:",
            "3": "- data is of a type (that's the first byte) that nature has no representation for$(br)- the transmission is missing some data at the end$(br)- the data is too large (seems like this could be different limit than the one going in the other direction...)$(br)- a variant of the above: the same matrix size restrictions apply (though it's impossible to have too many rows or columns, the total area could still be too much)",
            "4": "also note that lists can also partially fail to transfer, leading to the entire decoder potentially derailing and interpreting types as data and vice versa. good luck!$(br2)~t"
          }
        }
      },
      protocol: {
        "": "Iota Transport Protocol",
        "1": "Ah, the freedom! I've drawn up some diagrams of the format."
      },
      admin: {
        // These entries are only rendered in hexdoc, so we don't have to worry
        // about not overflowing the page!
        fsb: {
          "": "About FSB",
          "1": "mediatransport relies on $(n)Figura Server Backend/$ (also called $(n)FSB/$) to function. FSB is a feature in the development builds of Figura for 1.20.1 that enables hosting avatars and pings on the server itself instead of relying on the global backend.",
          "2": "FSB $(n)doesn't work on Singleplayer/$ or LAN worlds, so you might want to host a dedicated server to test your hexes out. Thanks for playing our addon! :)$(br2)$(l:https://github.com/penguinencounter/Figura/releases/tag/figura-fsb-placeholder)Figura FSB builds on GitHub$(/l)",
        },
        config: {
          "": "mediatransport config",
          "1": "mediatransport has various server configuration options to limit what data can be sent between avatars and casting environments.",
          maxSize: {
            "": "Size Restrictions",
            "1": "All values in bytes.$(br2)$(n)maximumSendSize/$: maximum amount of data that can be sent through $(l:hexcasting:patterns/figura#mediatransport:send_fsb)Submit Iota$(/l).$(br2)$(n)maximumInterSendSize/$: maxmimum amount of data that can be sent through $(l:hexcasting:patterns/figura#mediatransport:send_other)Submit Iota II$(/l).$(br2)$(n)maximumRecvSize/$: maximum amount of data that can be received from Figura. If this is exceeded, garbage will be pushed into the queue instead of the actual data.$(br2)$(n)matrixMaxArea/$: MoreIotas only; sets the maximum matrix area (width * height) that can be sent or receieved, separately from other restrictions and the maximum row/column count of 255."
          },
          filterIntro: {
            "": "Filters",
            "1": "mediatransport has three separate $(italic)filter/$ configuration sets for controlling what types of iota can be sent. Each one has a $(n)mode/$ and a $(n)list of entries/$.$(br2)The $(n)mode/$ can either be $(bold)\"Block\"/$ (forbids certain types, 'blocklist') or $(bold)\"Allow\"/$ (only allows certain types, 'allowlist').$(br2)The list contains the list of resource locations to apply the filter with. For example, to disallow sending lists, set the $(n)mode/$ to $(bold)\"Block\"/$ and the list to $(bold)[\"hexcasting:list\"]/$.$(br2)Note that allowing an iota type won't magically make it sendable if mediatransport lacks encoders or decoders for that type."
          },
          sendFilters: {
            "": "Sending Filters",
            "1": "Just like the size limits, there are separate filters for $(l:hexcasting:patterns/figura#mediatransport:send_fsb)Submit Iota$(/l) and $(l:hexcasting:patterns/figura#mediatransport:send_other)Submit Iota II$(/l).$(br2)$(n)sendFilter/$ and $(n)sendFilterMode/$ apply to Submit Iota. $(n)interSendFilter/$ and $(n)interSendFilterMode/$ apply to Submit Iota II.$(br2)If an iota is blocked by these filters, it will cause an 'bad type' mishap on the relevant iota (even if it's nested in a list.)"
          },
          recvFilters: {
            "": "Receiving Filters",
            "1": "$(n)recvFilter/$ and $(n)recvFilterMode/$ control what types of iota can be received from Figura.$(br2)Any iota that are blocked by this filter are replaced with Garbage, but any containing iota will be unaffected. (ex. a list containing an invalid iota will be received as a list containing garbage instead, provided lists are allowed.)"
          },
        }
      },
      figura_see_also_1: "I've cataloged the rest of the details in these entries.",
      see_also: "See Also",
      index: {
        "": "Transports: Index",
        desc: "An index of all the entries related to transports and Figura.",
      },
      blank: "$(#b0b0b0)this page left blank for layout purposes/$",
      blank_dark: "$(#504060)this page left blank for layout purposes/$",
    },
    // "can't send (iota) because..."
    not_sendable: {
      bad_type: "that type of iota can't be sent",
      corrupt: "it's corrupted or ill-formed",
      matrix_too_big: "it's too big",
      matrix_too_many_rows: "it has too many rows (max 255)",
      matrix_too_many_cols: "it has too many columns (max 255)",
    },
    radio_silence_options: {
      // translators: good luck, sorry (you can replace all of these with the 'help' one if you want)
      crickets: "*crickets*",
      ellipsis: "......",
      help: "Recieving queue is empty",
      eof: "java.util.NoSuchElementException: collection is empty",
      insanity: "You hear whispering, but you can't make it out.",
      informal: "there's nothing here.",
    },
    mishap_names: {
      init_fail: "Transport Init Failure",
      bad_type: "Not a Submittable Iota",
      corrupted: "Corrupt Iota",
      matrix_too_large: "Matrix Too Large",
      iota_too_large: "Send Too Large",
      iota_too_large_inter: "Send Other Too Large",
      radio_silence: "Nothing to Accept"
    },
  },
  hexcasting: {
    action: {
      "mediatransport:": {
        send_fsb: "Submit Iota",
        send_other: "Submit Iota II",
        recv_fsb: "Accept Iota",
        check_queue: "Semaphore's Reflection",
      },
      // use this to add shortened versions of pattern names if the full name won't fit in the ingame book
      // you don't need to add an entry for every pattern - the above value will be used as a default
      book: {
        "mediatransport:": {
          check_queue: "Semaphore's Refl.",
        },
      },
    },
    mishap: {
      not_sendable: "can't send %s",
      not_sendable_ex: "can't send %s because %s",
      too_large_to_send: "can't send: calculated size at least %s B, but server configured limit is %s B",
      too_large_to_send_inter: "can't send to other players: calculated size at least %s B, but server configured limit is %s B",
      fsb_not_initialized: "Figura server isn't initialized (tell your local admin to use a dedicated server and install FSB)",
      radio_silence: "%s",
      // see mediatransport.radio_silence_options
    }
  },
}
